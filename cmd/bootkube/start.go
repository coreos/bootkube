package main

import (
	"errors"
	"fmt"
	"strings"

	"github.com/spf13/cobra"

	"github.com/kubernetes-incubator/bootkube/pkg/bootkube"
)

var (
	cmdStart = &cobra.Command{
		Use:          "start",
		Short:        "Start the bootkube service",
		Long:         "",
		PreRunE:      validateStartOpts,
		RunE:         runCmdStart,
		SilenceUsage: true,
	}

	startOpts struct {
		assetDir        string
		podManifestPath string
		strict          bool
		requiredPods    []string
	}
)

var defaultRequiredPods = []string{
	"kube-system/pod-checkpointer",
	"kube-system/kube-apiserver",
	"kube-system/kube-scheduler",
	"kube-system/kube-controller-manager",
}

func init() {
	cmdRoot.AddCommand(cmdStart)
	cmdStart.Flags().StringVar(&startOpts.assetDir, "asset-dir", "", "Path to the cluster asset directory. Expected layout generated by the `bootkube render` command.")
	cmdStart.Flags().StringVar(&startOpts.podManifestPath, "pod-manifest-path", "/etc/kubernetes/manifests", "The location where the kubelet is configured to look for static pod manifests.")
	cmdStart.Flags().BoolVar(&startOpts.strict, "strict", false, "Strict mode will cause bootkube to exit early if any manifests in the asset directory cannot be created.")
	cmdStart.Flags().StringSliceVar(&startOpts.requiredPods, "required-pods", defaultRequiredPods, "List of pods with their namespace that are required to be running (or ready) before the start command does the pivot (written as <namespace>/<pod-name> or <namespace>/<pod-name>=<status>, where <status> is either the default \"running\" or \"ready\").")
}

func runCmdStart(cmd *cobra.Command, args []string) error {
	cfg := bootkube.Config{
		AssetDir:        startOpts.assetDir,
		PodManifestPath: startOpts.podManifestPath,
		Strict:          startOpts.strict,
	}

	for _, p := range startOpts.requiredPods {
		rp, err := parseRequiredPod(p)
		if err != nil {
			return err
		}
		cfg.RequiredPods = append(cfg.RequiredPods, rp)
	}

	bk, err := bootkube.NewBootkube(cfg)
	if err != nil {
		return err
	}

	err = bk.Run()
	if err != nil {
		// Always report errors.
		bootkube.UserOutput("Error: %v\n", err)
	}
	return err
}

func validateStartOpts(cmd *cobra.Command, args []string) error {
	if startOpts.podManifestPath == "" {
		return errors.New("missing required flag: --pod-manifest-path")
	}
	if startOpts.assetDir == "" {
		return errors.New("missing required flag: --asset-dir")
	}
	for _, p := range startOpts.requiredPods {
		if _, err := parseRequiredPod(p); err != nil {
			return err
		}
	}
	return nil
}

func parseRequiredPod(p string) (bootkube.RequiredPod, error) {
	ss := strings.Split(p, "=")
	if len(ss) != 1 && len(ss) != 2 {
		return bootkube.RequiredPod{}, fmt.Errorf("invalid required pod: expected %q to be of shape <namespace>/<pod-name> or <namespace>/<pod-name>=<status>", p)
	}
	nsPod, status := ss[0], ss[1]
	ss = strings.Split(nsPod, "/")
	if len(ss) != 2 {
		return bootkube.RequiredPod{}, fmt.Errorf("invalid required pod: expected %q to be of shape <namespace>/<pod-name> or <namespace>/<pod-name>=<status>", p)
	}
	ns, name := ss[0], ss[1]

	ret := bootkube.RequiredPod{
		Namespace: ns,
		Name:      name,
	}
	switch strings.ToLower(status) {
	case "ready":
		ret.Status = bootkube.PodStatusReady
	case "running":
		ret.Status = bootkube.PodStatusRunning
	default:
		return bootkube.RequiredPod{}, fmt.Errorf("invalid required pod %s/%s status %q: expected either \"ready\" or \"running\"", ns, name, status)
	}

	return ret, nil
}
